## OpenCode Skill 实现架构

### 核心设计：Tool 即 Skill 的入口

```
┌─────────────────────────────────────────────────────┐
│ 用户对话接口（Chat Interface）                      │
└─────────────────────────────────────────────────────┘
                          │
                          ▼
┌─────────────────────────────────────────────────────┐
│ 工具调用层（Tools Layer）                          │
│                                                     │
│ - skill_search: "查找相关技能" 元工具              │
│   └─ 输入: 自然语言查询                             │
│   └─ 输出: 匹配技能列表（含描述、路径、置信度）    │
│                                                     │
│ - skill_use: "加载技能内容" 元工具                 │
│   └─ 输入: 技能路径                                 │
│   └─ 输出: 完整 SKILL.md 内容（注入对话）          │
│                                                     │
│ - skill_resource: "获取技能资源" 可选工具          │
│   └─ 输入: 资源路径                                 │
│   └─ 输出: 代码片段、配置等辅助文件                │
└─────────────────────────────────────────────────────┘
                          │
                          ▼
┌─────────────────────────────────────────────────────┐
│ 技能注册表（SkillRegistry - 服务层）               │
│                                                     │
│ 职责：                                              │
│ 1. 文件系统扫描（watch 或按需）                    │
│    └─ 搜索 **/SKILL.md 文件                        │
│    └─ 遵循优先级：项目级 > 用户级 > 系统级         │
│                                                     │
│ 2. 前端元数据解析                                  │
│    └─ frontmatter (yaml/toml)                     │
│    └─ name, description, version, permissions      │
│                                                     │
│ 3. 索引与缓存                                      │
│    └─ 建立查询向量索引                             │
│    └─ 热重载支持                                   │
└─────────────────────────────────────────────────────┘
                          │
                          ▼
┌─────────────────────────────────────────────────────-┐
│ 内容注入层（Message Injection）                     │
│                                                     │
│ 关键技术：                                          │
│ 1. XML 序列化包装                                  │
│    <skill name="..." description="...">            │
│      <content>...</content>                        │
│      <resources>...</resources>                    │
│    </skill>                                        │
│                                                     │
│ 2. 动态上下文管理                                  │
│    └─ 仅注入最相关的 1-3 个技能                    │
│    └─ 避免 token 爆炸                              │
└─────────────────────────────────────────────────────┘
```

### 关键设计决策

| 维度 | OpenCode 方案 | 替代方案 | 优劣分析 |
|------|---------------|----------|----------|
| **Skill 入口** | 显式 Tool (`skill_search/use`) | 隐式注入（自动发现） | ✅ 显式更可控，避免意外加载；❌ 需要额外 tool 调用 |
| **状态管理** | 无状态，每次加载完整内容 | 有状态，缓存已加载技能 | ✅ 简单可靠；❌ 重复解析开销 |
| **作用域** | 目录树驱动（发现式） | 中央注册表（声明式） | ✅ 符合开发者习惯；❌ 难以全局管控 |
| **权限** | 文件系统权限继承 | 细粒度 ACL | ✅ 零配置；❌ 企业场景受限 |
| **兼容性** | 开放标准（SKILL.md） | 私有协议 | ✅ 跨工具复用；❌ 标准演进慢 |

### 工作流程示例

**场景**：用户说"帮我优化这段 React 代码"

```
1. 用户输入 → 模型判断是否需要 skill
   └─ 可能调用 skill_search("React optimization")

2. skill_search 执行
   └─ 扫描找到 skills/react/performance-tuning/SKILL.md
   └─ 返回：{ name: "React性能调优", path: "...", relevance: 0.94 }

3. 模型决策 → 调用 skill_use("skills/react/...")
   └─ 加载完整 markdown 内容
   └─ Registry 解析 frontmatter 和 body

4. 内容注入
   └─ 包装成 XML 添加到 system prompt
   └─ 模型获得临时专家知识

5. 模型生成优化建议
   └─ 基于注入的 skill 知识
   └─ 回答后 skill 内容丢弃（无状态）
```

### 设计哲学

**为什么用 Tool 而不是直接注入？**

1. **延迟加载**：避免每个请求都扫描文件系统
2. **模型自主**：让 LLM 自己判断需要哪个 skill（涌现能力）
3. **可观测性**：tool 调用日志清晰展示 skill 使用轨迹
4. **热插拔**：skill 增删无需重启服务，立即生效

**对比 MCP 的架构差异**

```
MCP: 模型 ←→ MCP 协议层 ←→ 资源/工具
     └─ 标准化通信，但模型无选择权

OpenCode Skills: 模型 → Tool 调用 → Skill 文件
     └─ 模型主动发现和使用，去中心化
```

### 适用场景分析

✅ **适合**：
- 个人/团队编码助手（技能随项目代码版本管理）
- 快速迭代领域知识（改 markdown 即可）
- 多工具生态（VS Code, Cursor, Claude Code 复用）

❌ **不适合**：
- 需要严格权限审计的企业平台
- 技能之间复杂依赖管理
- 海量技能（>1000）的高性能检索

### 待澄清的设计点

在实现前我们需要决定：

1. **检索策略**：模糊搜索 vs 向量相似度 vs 关键词匹配？
2. **缓存机制**：是否缓存解析后的 skill 对象？
3. **注入限制**：单个请求最多注入几个 skill？按什么优先级？
4. **错误处理**：skill 文件解析失败应该静默忽略还是报错？
5. **热重载**：开发时是否监听文件变化实时更新？